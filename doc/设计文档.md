# THSSDB 设计文档

## 小组成员

游嘉诚  软件91  2019013246

张嘉林  软件93  2018013323

朱思漠  软件92  2018012209

## 任务完成情况

完成了大作业说明文档里的所有基础要求，包括：

- 查询模块：对于所有要求的SQL语句，实现查询执行功能。
- 事务并发与恢复模块：实现read committed隔离级别；实现事务的WAL机制，重启时正确恢复数据（不会恢复未提交的数据变更）。

此外，我们还完成了一些进阶项，包括：

- on, where支持任意条件逻辑运算。
- 任意条件逻辑运算中每个条件支持任意算术运算和比较，支持列和字面量出现在运算的任意位置。
- 支持任意张表进行join运算。
- 支持任意投影，在natural join时投影和where条件可省略表名。
- 使用Rigorous 2PL+表级锁实现了可序列化的隔离级别。
- 实现多事务并发的恢复机制。

## 功能实现

### 查询模块

查询模块实现了所有要求的SQL语句。
- create table
- drop table(助教下发的ThssDB已实现)
- show table
- insert
- update
- delete
- select

特别地，对insert语句：
- table名后可不列出column名，默认为table中的全部column（按定义时顺序）
- 列出的column名可以是table中column的任意子集的任意排列
- values后可跟多个元组，每个元组中值的顺序和列出的column保持一致

单个insert、update语句是原子的，完全合法则完全生效，否则完全不生效（存在重复主键或不满足约束的元组）。

单个delete语句也是原子的，完全合法则完全生效，否则完全不生效，虽然理论上不存在由用户输入不合理导致的部分合法的情况。

对于update，delete和select中的on和where：
- 支持任意多条件逻辑运算
- 每个条件支持任意算术运算和比较（字符串不支持运算，但支持比较）
- 支持引用列和字面量出现在运算的任意位置
- natural join时where条件引用列可省略表名，也可不省略
- 引用列名有歧义或非法时会返回相应的报错信息

对于update中的set column = expression：
- value可以是任意算术表达式
- 支持引用列和字面量出现在运算的任意位置
- 字符串不支持运算，但支持引用列和字面量

对于select中的投影：
- 支持任意无歧义投影：任意顺序，任意重复
- `列名`、`表名.*`和`*`可任意组合
- natural join时可省略表名，也可不省略
- 投影有歧义或非法时会返回相应的报错信息

对于select中的join：
- 支持任意多张表theta join(... join ... join ... on ...)
- 支持任意多张表natural join(... join ... join ...)


### 事务并发与恢复模块

对于事务并发控制，实现了**可序列化**(Serializable)级别的隔离。

- 读已提交级别：当不同事务对同一张表先后进行写入和读时，读会被暂时阻塞进行等待。
- 可重复读级别：当不同事务对同一张表先后进行读和Update时，Update会被暂时阻塞进行等待；
- 可序列化级别：当不同事务对同一张表先后进行读和Insert时，Insert会被暂时阻塞进行等待；

并发控制采用了**严格两阶段锁**与**表级**共享**锁**(S锁)和排他锁(X锁)完成。

在该隔离等级下，事务读不会阻塞其他事务读，事务读会阻塞其他事务写，事务写会阻塞其他事务读和写。锁定的粒度是表级别的。
当一个客户端连接对表进行更新操作时，对更新的表请求“持续-X”锁；当一个客户端连接对表进行查询操作时，对查询的表请求“临时-S锁”实现。

## 实现方法概述

### 查询模块

任意投影、任意on/where条件均基于对语法树递归求值实现

通过给定表名到表中列名的映射和表名到Row的映射，实现在语法树的叶子结点对引用列的求值

任意多张表的join：
- 通过实现多List的笛卡尔积的迭代器+在线条件过滤实现
- 不会在内存中存储未经on和where条件过滤的中间结果

### 事务并发与恢复模块

#### 事务并发模块

考虑到`Thrift`提供的`Server`(本项目中，使用到了`TThreadpoolserver`代替初始的`TSimpleServer`来支持多线程连接多个客户端)对于不同的客户端连接可能使用线程池中的同一个工作线程处理，并且，同一连接的不同请求也可能被发往不同的工作线程处理。在连接和线程非绑定的情景下，Java标准中的`ReadWriteLock`是根据线程判断锁的所有权，因此使用Java的内置读写锁并不能有效地实现并发控制的需求。

对于这种情况，我们实现了基于客户端连接`SessionID`(而非线程)判断所有权的锁`SessionLock`类，并使用共享锁和排他锁的理念实现了该类的`SAcquire(SessionID)`、`XAcquire(SessionID)`、`SRelease(SessionID)`、`XRelease(SessionID)`、`canXAcquire(SessionID)`、`canSAcquire(SessionID)`等方法，分别用于基于客户端连接`SessionID`的共享锁、排他锁的请求、释放和查询。使用`SessionLock`避免了诸如不同连接被同一线程处理导致的脏读、同一连接使用不同进程导致死锁等情况。

以上为我们自定义的会话锁的设计理念。

在具体的操作中，每个表持有一个会话锁实例。当收到客户端的请求时，根据操作类型对表申请共享锁或排他锁，如果申请成功则执行逻辑，否则阻塞当前请求直至申请成功。

特别地，我们对SQL的执行顺序是：获取锁=>写WAL=>执行，这保证了WAL生成的statement based log是lock free的，可以单线程带锁执行。

从而支持了多事务并发的恢复。

#### 恢复模块

首先从log尾向前读，
通过同session（修改了write log以记录session）
commit和begin配对，
维护一个committed session集合（遇commit加入，遇begin移出），
标记所有已提交的statement。

再从头向后读，执行所有已提交的statement

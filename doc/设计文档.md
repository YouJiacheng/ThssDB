# THSSDB 设计文档

## 小组成员

游嘉诚  软件91  2019013246

张嘉林  软件93  2018013323

朱思漠  软件92  2018012209

## 任务完成情况

完成了大作业说明文档里的所有基础要求，包括：

- 查询模块：对于所有要求的SQL语句，实现查询执行功能。
- 事务并发与恢复模块：实现read committed隔离级别；实现事务的WAL机制，重启时正确恢复数据（不会恢复未提交的数据变更）。

此外，我们还完成了一些进阶项，包括：

- on, where支持任意多条件逻辑运算。
- on, where每一个条件支持任意算术运算和比较，支持列和字面量出现在运算的任意位置。
- 支持任意张表进行join运算。
- 支持任意投影，在natural join时投影和where条件可省略表名。
- 使用Rigorous 2PL+表级锁实现了可序列化的隔离级别。
- 实现多事务并发的恢复机制。

## 功能实现

### 查询模块





### 事务并发与恢复模块

对于事务并发控制，实现了**可序列化**(Serializable)级别的隔离。

- 可重复读级别：当不同事务对同一张表先后进行读和Update时，Update会被暂时阻塞进行等待；
- 可序列化级别：当不同事务对同一张表先后进行读和Insert时，Insert会被暂时阻塞进行等待；
- 读已提交级别：当不同事务对同一张表先后进行写入和读时，读会被暂时阻塞进行等待。

并发控制采用了**严格两阶段锁**与**表级**共享**锁**(S锁)和排他锁(X锁)完成。

在该隔离等级下，事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写。
当一个客户端连接对表进行更新操作时，对更新的表请求“持续-X”锁；当一个客户端连接对表进行查询操作时，对查询的表请求“临时-S锁”实现。

## 实现方法概述

### 查询模块



### 事务并发与恢复模块

#### 事务并发模块

考虑到`Thrift`提供的`Server`(本项目中，使用到了`TThreadpoolserver`代替初始的`TSimpleServer`来支持多线程连接多个客户端)对于不同的客户端连接可能使用线程池中的同一个工作线程处理，并且，同一连接的不同请求也可能被发往不同的工作线程处理。在连接和线程非绑定的情景下，Java标准中的`ReadWriteLock`是根据线程判断锁的所有权，因此使用Java的内置读写锁并不能有效地实现并发控制的需求。

对于这种情况，我们实现了基于客户端连接`SessionID`(而非线程)判断所有权的锁`SessionLock`类，并使用共享锁和排他锁的理念实现了该类的`SAcquire(SessionID)`、`XAcquire(SessionID)`、`SRelease(SessionID)`、`XRelease(SessionID)`、`canXAcquire(SessionID)`、`canSAcquire(SessionID)`等方法，分别用于基于客户端连接`SessionID`的共享锁、排他锁的请求、释放和查询。使用`SessionLock`避免了诸如不同连接被同一线程处理导致的脏读、同一连接使用不同进程导致死锁等情况。

以上为我们自定义的会话锁的设计理念。

在具体的操作中，每个表持有一个会话锁实例。当收到客户端的请求时，根据操作类型对表申请共享锁或排他锁，如果申请成功则执行逻辑，否则阻塞当前请求直至申请成功。

#### 恢复模块